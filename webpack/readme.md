## webpack - конфигурационный файл

Webpack использует функции require() и module.exports() для подключения или экспортирования js-модулей. С точки зрения webpack (и Nodejs) любой js-файл - это js-модуль, который можно использовать многократно.

Webpack позволяет собирать несколько модулей в один, результирующий модуль. В этом случае один модуль играет роль главного, в который собираются все остальные модуля. О том, что в главный модуль нужно подключить дополнительный (*как зависимость*) модуль, "говорит" запись в главном модуле:

```javascript
var someModule = require('./some-module');
```

Webpack читает такую строку и понимает ее так - создать переменную someModule и поместить в нее ссылку на модуль some-module.js, путь подключения к которому указывается в качестве аргумента в функции require().

Можно сказать (*как мне кажется*) и так - "давайте подключим модуль some-module.js внутрь модуля app.js и дадим этому модулю имя someModule; теперь модуль some-module.js внутри модуля app.js будет известен как someModule и вызывать на исполнение мы его будем по этому имени - someModule".

Теперь можно использовать (*вызывать*) **внутри главного модуля** подключенный модуль some-module.js по ссылке someModule:

```javascript
// вызывает исполнение модуля someModule в модуле app
someModule('param');
```

"Сердце" webpack - его конфигурационный файл `webpack.config.js`. В этом файле есть две самые главные строки:

 - точка входа (entry)
 - точка выхода (output)

**Точка входа** - это путь к тому самому главному модулю, внутри которого подключаются все дополнительные модуля. Простыми словами - это то, что webpack будет собирать.

**Точка выхода** - это имя и путь расположения результирующего модуля. Простыми словами - это то, что получится в результате.

```javascript
module.exports = {
  entry: './app.js',
  output: {
    filename: './build.js' // имя и путь результирующего модуля
  }
}
```

## webpack - внешний доступ к модулям

Webpack в результате своей работы собирает несколько модулей в один модуль (js-файл). Главный модуль и дополнительные модуля соединяются в единый модуль и составляют единое целое. Вычленить из такого целого какой-либо составной модуль (и использовать его отдельно) не представляется возможным.

Но webpack имеет в своем составе инструмент, с помощью которого можно в процессе сборки создать библиотеку, в которую будут входить составные модуля - как методы этой библиотеки.

Например, собирается результирующий модуль build.js; и он преобразовывается таким образом, чтобы в дальнейшем можно было использовать любой из подключаемых модулей как метод этой библиотеки. Эту библиотеку можно вызывать в любое время и в любом месте:

```javascript
module.exports = {
  entry: './app.js',
  output: {
    filename: './build.js'
  },
  library: 'lib' // имя создаваемой библиотеки
}
```

Но перед этим необходимо экспортировать подключаемый модуль внутри главного модуля, то есть - сделать этот дополнительный модуль доступным извне. В результате экспортируемый модуль будет помещен в переменную lib (в библиотеку).

```javascript
// экспорт модуля someModule в библиотеку lib под именем exportedModule
exports.exportedModule = someModule;
```

И затем можно уже использовать этот модуль как метод библиотеки lib:

```script
lib.exportedModule('DOM')
```

## webpack - автоматическая пересборка

Webpack в своем конфигурационном файле имеет настройку `watch: true` для **автосборки** модулей. Другими словами, это отслеживание изменений в фоновом режиме и автоматический перезапуск сборки:

```javascript
module.exports = {
  entry: './app.js',
  output: {
    filename: './build.js'
  },
  library: 'lib.js',
  watch: true
}
```

У настройки watch есть дополнительная опция watchOptions, одним из ключей которой является возможность **временной задержки** перед сборкой. Это имеет смысл делать для того, чтобы дать время редактору кода (Sublime Text, WebStorm, Atom и любой другой) успеть сохранить изменения в файлах, которые были отредактированы.

Выглядит это таким образом:

```javascript
module.exports = {
  entry: './app.js',
  output: {
    filename: './build.js'
  },
  library: 'lib.js',
  watch: true,
  watchOptions: {
    aggregateTimeout: 100
  }
}
```

По умолчанию значение ключа `aggregateTimeout` равно 300, но можно поменять его на 100.


## webpack - sourcemaps

Webpack поддерживает различные **режимы отладки**. Зачем нужен режим отладки и как его использовать - это возможность копаться не в результирующей "простыне" кода, а в исходном файле каждого из модулей в отдельности.

В браузере создается виртуальная файловая структура, состоящая из главного модуля и всех подключаемых в нему модулей. И при отладке какой-либо строки кода браузер "перебрасывает" в тот модуль, в котором эта строка находилась изначально.

Другими словами, не нужно рыться в большом build.js, а можно покопаться в маленьком some-module.js. Достоинство режима отладки - в его удобстве.

В конфигурационном файле режим отладки включается при помощи строки `devtool`:

```javascript
module.exports = {
  entry: './app.js',
  output: {
    filename: './build.js'
  },
  library: 'lib.js',
  watch: true,
  watchOptions: {
    aggregateTimeout: 100
  },
  // подключаем выбранный нами режим отладки
  devtool: 'cheap-inline-module-source-map'
}
```

Значениями строки могут быть любой из списка - (Webpack Devtool)[http://webpack.github.io/docs/configuration.html#devtool "Webpack Devtool"].

Более того, значения можно комбинировать. Например, превратить `source-map` в `cheap-inline-module-source-map`.


## webpack - development and production

Блядь, вот запутано здесь! надо время для освоения.


## webpack - loaders

Loader - это сторонний модуль под webpack, служащий для различной обработки не менее различных файлов сборки. Такие модули называются "загрузчиками" - loaders.

Например, для преобразования js-файлов из ES6 в ES5 имеется модуль (babel-loader)[https://github.com/babel/babel-loader "Webpack plugin for Babel"].

В базовой конфигурации вызов loader'а из `webpack.config.js` выглядит таким образом:

loaders: [
  {
    test: /\.js$/,
    loader: 'babel'
  }
] 

Первая строка - `test` в качестве аргумента принимает регулярное выражение, в котором задается, какие файлы нужно обрабатывать; в данном случае мы хотим "мониторить" все файлы с расширением js.

Вторая строка - `loader` содержит **имя модуля**, который мы хотим вызывать и использовать. В данном случае это модуль (babel-loader)[https://github.com/babel/babel-loader "Webpack plugin for Babel"]. Здесь приведено сокращенное имя модуля babel-loader - babel, ибо webpack и так поймет нас )

В сухом остатке приведенного выше кода мы имеем - вызываем модуль babel-loader для обработки всех файлов с расширением js, чтобы преобразовывать ES6 в ES5.

Не забываем предварительно установить модуль babel-loader локально перед запуском webpack:

```bash
npm i babel-loader
```

Возвращаясь немного назад к конфигурационнному файлу webpack.config.js и строке подключения загрузчиков (loaders) стоить обратить внимание, что это **массив**.

Поэтому подобных загрузчиков (типа рассмотренного выше babel-loader) в конфиге webpack может быть больше одного (как минимум). Один загрузчик - для обработки js-файлов, другой загрузчик - для обработки css-файлов (css-loader), третий - еще для чего-то и так далее.






















